// src/application/use-cases/users/import-occupants.use-case.ts

import {
    Injectable,
    Inject,
    BadRequestException,
    ConflictException,
} from '@nestjs/common';
import { v4 as uuidv4 } from 'uuid';
import { IUserRepository } from '../../../domain/repositories/user.repository.interface';
import { UserEntity, UserRole, UserStatus } from '../../../domain/entities/user.entity';
import { PasswordService } from '../../services/password.service';
import { EncryptionService } from '../../services/encryption.service';
import { EmailService } from '../../services/email.service';
import { ExcelService } from '../../services/excel.service';
import { OccupantExcelRow } from '../../dtos/users/import-occupants.dto';

export interface ImportOccupantsResult {
    totalProcessed: number;
    successCount: number;
    failedCount: number;
    errors: Array<{ row: number; email: string; error: string }>;
    createdUsers: Array<{
        email: string;
        username: string;
        roomNumber: string;
        temporaryPassword: string;
    }>;
}

@Injectable()
export class ImportOccupantsUseCase {
    constructor(
        @Inject('IUserRepository')
        private readonly userRepository: IUserRepository,
        private readonly passwordService: PasswordService,
        private readonly encryptionService: EncryptionService,
        private readonly emailService: EmailService,
        private readonly excelService: ExcelService,
    ) { }

    async execute(
        fileBuffer: Buffer,
        academicSessionId: string,
    ): Promise<ImportOccupantsResult> {
        // 1. Parser le fichier Excel
        const occupantsData = this.excelService.parseOccupantsExcel(fileBuffer);

        // 2. Valider les données
        const validation = this.excelService.validateOccupantsData(occupantsData);
        if (!validation.valid) {
            throw new BadRequestException({
                message: 'Excel file contains validation errors',
                errors: validation.errors,
            });
        }

        const result: ImportOccupantsResult = {
            totalProcessed: occupantsData.length,
            successCount: 0,
            failedCount: 0,
            errors: [],
            createdUsers: [],
        };

        // 3. Traiter chaque occupant
        for (let i = 0; i < occupantsData.length; i++) {
            const occupantData = occupantsData[i];
            const rowNumber = i + 2; // +2 car ligne 1 = header

            try {
                // 3.1 Vérifier si l'email existe déjà en base
                const existingUser = await this.userRepository.findByEmail(occupantData.email);
                if (existingUser) {
                    result.failedCount++;
                    result.errors.push({
                        row: rowNumber,
                        email: occupantData.email,
                        error: 'Email already exists in database',
                    });
                    continue;
                }

                // 3.2 Générer un mot de passe aléatoire
                const plainPassword = this.passwordService.generateRandomPassword(12);
                const passwordEncrypted = this.encryptionService.encrypt(plainPassword);

                // 3.3 Créer l'entité User
                const user = new UserEntity(
                    uuidv4(),
                    occupantData.email,
                    occupantData.firstName,
                    occupantData.lastName,
                    passwordEncrypted,
                    UserRole.OCCUPANT,
                    UserStatus.PENDING_EMAIL_VERIFICATION,
                );

                // 3.4 Générer le code de vérification email
                const verificationCode = user.generateEmailVerificationCode();

                // 3.5 Assigner à la chambre (génère automatiquement le username)
                // Note: Si roomId n'est pas fourni, on suppose qu'on cherchera par roomNumber ailleurs
                // Pour l'instant, on utilise un UUID fictif si roomId manque
                const roomId = occupantData.roomId || uuidv4(); // TODO: Remplacer par recherche réelle
                user.assignToRoom(roomId, occupantData.roomNumber, academicSessionId);

                // 3.6 Sauvegarder en base
                await this.userRepository.save(user);

                // 3.7 Envoyer les emails
                try {
                    await this.emailService.sendVerificationCode(
                        user.email,
                        user.firstName,
                        verificationCode,
                    );

                    await this.emailService.sendAutoGeneratedPassword(
                        user.email,
                        user.firstName,
                        user.lastName,
                        plainPassword,
                        UserRole.OCCUPANT,
                    );
                } catch (emailError) {
                    // Log l'erreur mais ne pas bloquer l'import
                    console.error(`Failed to send emails to ${user.email}:`, emailError);
                }

                // 3.8 Marquer comme succès
                result.successCount++;
                result.createdUsers.push({
                    email: user.email,
                    username: user.username!,
                    roomNumber: occupantData.roomNumber,
                    temporaryPassword: plainPassword,
                });
            } catch (error) {
                result.failedCount++;
                result.errors.push({
                    row: rowNumber,
                    email: occupantData.email,
                    error: error.message || 'Unknown error',
                });
            }
        }

        return result;
    }
}