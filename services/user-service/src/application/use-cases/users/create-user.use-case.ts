import {
    Injectable,
    Inject,
    ConflictException,
    ForbiddenException,
    BadRequestException,
    Logger,
} from '@nestjs/common';
import { v4 as uuidv4 } from 'uuid';
import { IUserRepository } from '../../../domain/repositories/user.repository.interface';
import { UserEntity, UserRole, UserStatus } from '../../../domain/entities/user.entity';
import { RoleHierarchy } from '../../../domain/value-objects/role-hierarchy.vo';
import { PasswordService } from '../../services/password.service';
import { EncryptionService } from '../../services/encryption.service';
import { EmailService } from '../../services/email.service';
import { CreateUserDto } from '../../dtos/users/create-user.dto';
import { UserResponseDto } from '../../dtos/users/user-response.dto';
import { RabbitMQPublisherService } from '../../../infrastructure/events/rabbitmq-publisher.service';

@Injectable()
export class CreateUserUseCase {
    private readonly logger = new Logger(CreateUserUseCase.name);

    constructor(
        @Inject('IUserRepository')
        private readonly userRepository: IUserRepository,
        private readonly passwordService: PasswordService,
        private readonly encryptionService: EncryptionService,
        private readonly emailService: EmailService,
        private readonly eventPublisher: RabbitMQPublisherService,
    ) { }

    async execute(
        createUserDto: CreateUserDto,
        creatorUserId: string,
    ): Promise<{ user: UserResponseDto; plainPassword: string }> {
        const creator = await this.userRepository.findById(creatorUserId);
        if (!creator) {
            throw new ForbiddenException('Creator user not found');
        }

        if (!RoleHierarchy.canCreate(creator.role, createUserDto.role)) {
            throw new ForbiddenException(
                `You do not have permission to create users with role ${createUserDto.role}`,
            );
        }

        const existingUser = await this.userRepository.findByEmail(createUserDto.email);
        if (existingUser) {
            throw new ConflictException('Email already exists');
        }

        const plainPassword = this.passwordService.generateRandomPassword(16);
        const passwordEncrypted = this.encryptionService.encrypt(plainPassword);

        const user = new UserEntity(
            uuidv4(),
            createUserDto.email,
            createUserDto.firstName,
            createUserDto.lastName,
            passwordEncrypted,
            createUserDto.role,
            UserStatus.PENDING_EMAIL_VERIFICATION,
        );

        const verificationCode = user.generateEmailVerificationCode();

        if (createUserDto.role === UserRole.OCCUPANT) {
            if (createUserDto.roomId && createUserDto.roomNumber && createUserDto.academicSessionId) {
                user.assignToRoom(
                    createUserDto.roomId,
                    createUserDto.roomNumber,
                    createUserDto.academicSessionId,
                );
            } else {
                throw new BadRequestException(
                    'OCCUPANT users must be assigned to a room',
                );
            }
        }

        await this.userRepository.save(user);

        // Publier l'événement avec le mot de passe temporaire pour l'email
        try {
            await this.eventPublisher.publishUserCreated({
                userId: user.id,
                email: user.email,
                firstName: user.firstName,
                lastName: user.lastName,
                role: user.role,
                temporaryPassword: plainPassword,
                passwordEncrypted: passwordEncrypted,
                status: user.status,
                emailVerified: user.emailVerified,
            });
        } catch (error) {
            const err = error as Error;
            this.logger.warn(`Failed to publish user.created event: ${err.message}`);
        }

        if (process.env.SMTP_ENABLED === 'true') {
            try {
                await this.emailService.sendVerificationCode(
                    user.email,
                    user.firstName,
                    verificationCode,
                );
            } catch (error) {
                const err = error as Error;
                this.logger.error('Failed to send verification email:', err.message);
            }

            try {
                await this.emailService.sendAutoGeneratedPassword(
                    user.email,
                    user.firstName,
                    user.lastName,
                    plainPassword,
                    user.role,
                );
            } catch (error) {
                const err = error as Error;
                this.logger.error('Failed to send password email:', err.message);
            }
        } else {
            this.logger.log(`⚠️ Email disabled - Verification code: ${verificationCode}`);
            this.logger.log(`⚠️ Email disabled - Temporary password: ${plainPassword}`);
        }

        const userResponse = new UserResponseDto({
            id: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            fullName: user.fullName,
            role: user.role,
            status: user.status,
            emailVerified: user.emailVerified,
            googleId: user.googleId,
            profilePicture: user.profilePicture,
            username: user.username,
            currentRoomId: user.currentRoomId,
            currentAcademicSessionId: user.currentAcademicSessionId,
            lastLoginAt: user.lastLoginAt,
            createdAt: user.createdAt,
            updatedAt: user.updatedAt,
        });

        return {
            user: userResponse,
            plainPassword,
        };
    }
}